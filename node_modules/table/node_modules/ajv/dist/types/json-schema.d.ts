export declare type SomeJSONSchema = JSONSchemaType<Known, true>;
export declare type PartialSchema<T> = Partial<JSONSchemaType<T, true>>;
declare type JSONType<T extends string, _partial extends boolean> = _partial extends true ? T | undefined : T;
<<<<<<< HEAD
interface NumberKeywords {
=======
export declare type JSONSchemaType<T, _partial extends boolean = false> = (T extends number ? {
    type: JSONType<"number" | "integer", _partial>;
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    minimum?: number;
    maximum?: number;
    exclusiveMinimum?: number;
    exclusiveMaximum?: number;
    multipleOf?: number;
    format?: string;
<<<<<<< HEAD
}
interface StringKeywords {
=======
} : T extends string ? {
    type: JSONType<"string", _partial>;
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    format?: string;
<<<<<<< HEAD
}
export declare type JSONSchemaType<T, _partial extends boolean = false> = (// these two unions allow arbitrary unions of types
{
    anyOf: readonly JSONSchemaType<T, _partial>[];
} | {
    oneOf: readonly JSONSchemaType<T, _partial>[];
} | ({
    type: (T extends number ? JSONType<"number" | "integer", _partial> : T extends string ? JSONType<"string", _partial> : T extends boolean ? JSONType<"boolean", _partial> : never)[];
} & (T extends number ? NumberKeywords : T extends string ? StringKeywords : T extends boolean ? unknown : never)) | ((T extends number ? {
    type: JSONType<"number" | "integer", _partial>;
} & NumberKeywords : T extends string ? {
    type: JSONType<"string", _partial>;
} & StringKeywords : T extends boolean ? {
=======
} : T extends boolean ? {
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    type: "boolean";
} : T extends [any, ...any[]] ? {
    type: JSONType<"array", _partial>;
    items: {
<<<<<<< HEAD
        readonly [K in keyof T]-?: JSONSchemaType<T[K]> & Nullable<T[K]>;
=======
        [K in keyof T]-?: JSONSchemaType<T[K]> & Nullable<T[K]>;
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    } & {
        length: T["length"];
    };
    minItems: T["length"];
} & ({
    maxItems: T["length"];
} | {
    additionalItems: false;
}) : T extends readonly any[] ? {
    type: JSONType<"array", _partial>;
    items: JSONSchemaType<T[0]>;
    contains?: PartialSchema<T[0]>;
    minItems?: number;
    maxItems?: number;
    minContains?: number;
    maxContains?: number;
    uniqueItems?: true;
    additionalItems?: never;
} : T extends Record<string, any> ? {
    type: JSONType<"object", _partial>;
<<<<<<< HEAD
    required: _partial extends true ? Readonly<(keyof T)[]> : Readonly<RequiredMembers<T>[]>;
=======
    required: _partial extends true ? (keyof T)[] : RequiredMembers<T>[];
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    additionalProperties?: boolean | JSONSchemaType<T[string]>;
    unevaluatedProperties?: boolean | JSONSchemaType<T[string]>;
    properties?: _partial extends true ? Partial<PropertiesSchema<T>> : PropertiesSchema<T>;
    patternProperties?: {
        [Pattern in string]?: JSONSchemaType<T[string]>;
    };
    propertyNames?: JSONSchemaType<string>;
    dependencies?: {
<<<<<<< HEAD
        [K in keyof T]?: Readonly<(keyof T)[]> | PartialSchema<T>;
    };
    dependentRequired?: {
        [K in keyof T]?: Readonly<(keyof T)[]>;
=======
        [K in keyof T]?: (keyof T)[] | PartialSchema<T>;
    };
    dependentRequired?: {
        [K in keyof T]?: (keyof T)[];
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    };
    dependentSchemas?: {
        [K in keyof T]?: PartialSchema<T>;
    };
    minProperties?: number;
    maxProperties?: number;
} : T extends null ? {
    nullable: true;
} : never) & {
<<<<<<< HEAD
    allOf?: Readonly<PartialSchema<T>[]>;
    anyOf?: Readonly<PartialSchema<T>[]>;
    oneOf?: Readonly<PartialSchema<T>[]>;
    if?: PartialSchema<T>;
    then?: PartialSchema<T>;
    else?: PartialSchema<T>;
    not?: PartialSchema<T>;
})) & {
=======
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    [keyword: string]: any;
    $id?: string;
    $ref?: string;
    $defs?: {
        [Key in string]?: JSONSchemaType<Known, true>;
    };
    definitions?: {
        [Key in string]?: JSONSchemaType<Known, true>;
    };
<<<<<<< HEAD
=======
    allOf?: PartialSchema<T>[];
    anyOf?: PartialSchema<T>[];
    oneOf?: PartialSchema<T>[];
    if?: PartialSchema<T>;
    then?: PartialSchema<T>;
    else?: PartialSchema<T>;
    not?: PartialSchema<T>;
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
};
declare type Known = KnownRecord | [Known, ...Known[]] | Known[] | number | string | boolean | null;
interface KnownRecord extends Record<string, Known> {
}
<<<<<<< HEAD
export declare type PropertiesSchema<T> = {
=======
declare type PropertiesSchema<T> = {
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    [K in keyof T]-?: (JSONSchemaType<T[K]> & Nullable<T[K]>) | {
        $ref: string;
    };
};
<<<<<<< HEAD
export declare type RequiredMembers<T> = {
=======
declare type RequiredMembers<T> = {
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    [K in keyof T]-?: undefined extends T[K] ? never : K;
}[keyof T];
declare type Nullable<T> = undefined extends T ? {
    nullable: true;
    const?: never;
<<<<<<< HEAD
    enum?: Readonly<(T | null)[]>;
    default?: T | null;
} : {
    const?: T;
    enum?: Readonly<T[]>;
=======
    enum?: (T | null)[];
    default?: T | null;
} : {
    const?: T;
    enum?: T[];
>>>>>>> c9839472c444f6ec2829e00bb0169a884834f986
    default?: T;
};
export {};
